load "ff-IpOpt"
load "medit"

real T = 1;
int nn = 50;
int Nx = nn, Ny = nn; 
int[int] labs = [1, 2, 0, 4];
mesh Th = square(Nx, Ny, [x, T * y], label = labs);
fespace Vh(Th, P1);

Vh ue = sin(pi * x) * sin(pi * y);
Vh uN = pi * cos(pi * x) * sin(pi * y);
Vh u0 = ue(x, 0);
Vh a = 1;
Vh q = x * y + 1;
Vh fe = (1 + y^0) * (x * (x <= 0.5) + (1 - x) * (x > 0.5)); 
Vh g = pi * sin(pi * x) * cos(pi * y) + a * pi^2 * sin(pi * x) * sin(pi * y) - fe * q;
real gamma = 1e-6;


Vh u, f = 0;

// State equation:
func real[int] StateProblem(real[int] & f){
    Vh u, v, ff; ff[] = f;
    Vh rsh = ff * q + g;

    solve SpaceTime(u, v, solver = sparsesolver) = 
          int2d(Th)(dy(u)  * v + a * dx(u)  * dx(v)) 
        + int2d(Th)(dy(u0) * v + a * dx(u0) * dx(v))
        - int1d(Th, 2) (uN * v) + int1d(Th, 4) (uN * v)
        - int2d(Th)(rsh * v) 
        + on(1, u = 0);

    u = u + u0;
    return u[];
}


func real[int] flip(real[int] u){
    Vh uu;
    for (int i =0; i <= Ny/2; i++){
        for (int j=0; j <= Nx; j++){
            uu[][i * (Nx + 1) + j] = u[(Ny - i) * (Nx + 1) + j];
            uu[][(Ny - i) * (Nx + 1) + j] = u[i * (Nx + 1) + j];
        }
    }
    return uu[];
}


// Adjoint equation
func real[int] AdjointProblem(real[int] & u){
    Vh p, v, uu; uu[] = u;
    Vh temp = uu - ue; 
    Vh rsh =  flip(temp[]);
    Vh pN = 0;

    solve SpaceTime(p, v, solver = sparsesolver) =
          int2d(Th)(dy(p) * v + a(x, T-y) * dx(p) * dx(v))
        - int1d(Th, 2, 4)(pN * v)
        - int2d(Th)(rsh * v) + on(1, p = 0);

    return flip(p[]);
}


// Tikhonov functional
func real J(real[int] & f) {
    Vh ff; ff[] = f;
    u[] = StateProblem(f); 
    return 0.5 * int2d(Th)((u - ue)^2) + 0.5 * gamma * int2d(Th)(ff^2);
}


// Gradient of Tikhonov funtional
func real[int] GradJ(real[int] & f) {
    Vh ff; ff[] = f;
    Vh p; p[] = AdjointProblem(StateProblem(f));
    Vh res = p * q + gamma * ff;
    return res[];
}

//Vh f = 0;
//IPOPT(J, GradJ, f[], tol = 1e-4);
//NLCG(GradJ, f[], nbiter=10, eps = 1e-3);
LinearCG(GradJ, f[], eps = 1e-6);

//savemesh(Th, "IP1.mesh");
//savesol("IP1.sol", Th, f);
//savemesh(Th, "IPe.mesh");
//savesol("IPe.sol", Th, fe);

//Vh u; u[] = StateProblem(f[]);

plot(ue, wait = 1, dim=3d);
plot(u, wait = 1, dim=3d);
plot(u, ue, wait = 1, dim=3d);

plot(fe, wait = 1, dim=3d);
plot(f, wait = 1, dim=3d);
plot(f, fe, wait = 1, dim=3d);
cout << "Error: " << sqrt(int2d(Th)((fe - f)^2)) << endl;
