load "ff-IpOpt"
load "medit"

real T = 1;
int nn = 50;
int Nx = nn, Ny = nn; 
int[int] labs = [1, 2, 0, 4];
mesh Th = square(Nx, Ny, [x, T * y], label = labs);
fespace Vh(Th, P1);


// ***** DATA ***** //
Vh ue = exp(y) * sin(pi * x);
Vh uD = 0;
Vh u0 = sin(pi * x);

Vh fe = x^2;//sin(pi * x);
 
Vh q = 2 + y^2;
Vh g = (1 + pi^2) * ue(x, y) - fe(x, y) * q(x,y);
real gamma = 1e-1;

// The final overdetermination
real[int] w(Nx + 1);
for (int i = 0; i <= Nx; i++){
    w[i] = ue(i * 1.0 / Nx, T);
}

real[int] ffe(Nx + 1);
for (int i = 0; i <= Nx; i++){
    ffe[i] = fe(1.0 * i / Nx, 0);
}





// ***** Functions to modify matrix ***** //

// ** Change the time direction
func real[int] FlipTimeDirection(real[int] mat){
    Vh res;
    for (int i = 0; i <= Ny/2; i++){
        for (int j = 0; j <= Nx; j++){
            res[][i * (Nx + 1) + j] = mat[(Ny - i) * (Nx + 1) + j];
            res[][(Ny - i) * (Nx + 1) + j] = mat[i * (Nx + 1) + j];
        }
    }
    return res[];
}

// ** To change vec(t) into vec(x, t) depending on the mesh
func real[int] TimeToQ(real[int] mat){
    Vh res = 0;
    for (int i = 0; i <= Ny; i++){
        for (int j = 0; j <= Nx; j++)
        res[][i * (Nx + 1) + j] = mat[i];
    }
    return res[];
}

// ** To change vec(x) into vec(x, t) depending on the mesh
func real[int] SpaceToQ(real[int] mat){
    Vh res = 0;
    for (int i = 0; i <= Nx; i++){
        for (int j = 0; j <= Ny; j++)
        res[][j * (Nx + 1) + i] = mat[i];
    }
    return res[];
}

// ** Get values from final time (t = T)
func real[int] GetFinalTime(real[int] mat){
    real[int] res(Nx + 1);
    for (int i = 0; i <= Nx; i++){
        res[i] = mat[Ny * (Nx + 1) + i];
    }
    return res;
}

// ** Get values from initial time (t = 0)
func real[int] GetInitialTime(real[int] mat){
    real[int] res(Nx + 1);
    for (int i = 0; i <= Nx; i++){
        res[i] = mat[i];
    }
    return res;
}

// ** Integrate on space
//   The result is a vector with respect to (t)
func real[int] IntegralOnSpace(real[int] mat){
    real[int] res(Ny + 1);
    Vh temp = 0;
    for (int i = 0; i <= Ny; i++){
        for (int j = 0; j <= Nx; j++){
            temp[][j] = mat[i * (Nx + 1) + j];
        }
        res[i] = int1d(Th, 1)(temp);
    }
    return res;
}

// * Integrate on time
//   The result is a vector with respect to (x)
func real[int] IntegralOnTime(real[int] mat){
    real[int] res(Nx + 1);
    Vh temp = 0;
    for (int i = 0; i <= Nx; i++){
        for (int j = 0; j <= Ny; j++){
            temp[][j * (Nx + 1)] = mat[j * (Nx + 1) + i];
        }
        res[i] = int1d(Th, 4)(temp);
    }
    return res;
}


// ** Inner product on time domain of vec1(t) and vec2(t)
func real InnerProductOnTime(real[int] vec1, real[int] vec2){
    real[int] vec(Ny + 1);
    for (int i = 0; i <= Ny; i++){
        vec[i] = vec1[i] * vec2[i];
    }

    // Take int1d on x = 0 (label = 4);
    Vh res = 0;
    for (int i = 0; i <= Ny; i++){
        res[][i * (Nx + 1)] = vec[i];
    }

    return int1d(Th, 4)(res);
}


// ** Inner product on time domain of vec1(x) and vec2(x)
func real InnerProductOnSpace(real[int] vec1, real[int] vec2){
    real[int] vec(Nx + 1);
    for (int i = 0; i <= Nx; i++){
        vec[i] = vec1[i] * vec2[i];
    }

    // Take int1d on x = 0 (label = 4);
    Vh res = 0;
    for (int i = 0; i <= Nx; i++){
        res[][i] = vec[i];
    }

    return int1d(Th, 1)(res);
}




// ***** State and Adjoint problems ***** //

// * State problem
func real[int] StateProblem(real[int] ff){
    Vh u, v, f; f[] = SpaceToQ(ff);
    Vh rsh = q * f + g;

    solve SpaceTime(u, v, solver = sparsesolver) = 
          int2d(Th)(dy(u)  * v + dx(u)  * dx(v)) 
        + int2d(Th)(dy(u0) * v + dx(u0) * dx(v))
        - int2d(Th)(rsh * v) 
        + on(1, 2, 4, u = 0);

    u = u + u0;
    return u[];
}

// * Problem 1
func real[int] StateProblem1(real[int] ff){
    Vh u, v, f; f[] = ff;
    Vh rsh = q * f;

    solve SpaceTime(u, v, solver = sparsesolver) = 
          int2d(Th)(dy(u) * v + dx(u) * dx(v))
        - int2d(Th)(rsh * v) 
        + on(1, 2, 4, u = 0);

    return u[];
}

// * Problem 2
func real[int] StateProblem2(){
    Vh u, v;

    solve SpaceTime(u, v, solver = sparsesolver) = 
          int2d(Th)(dy(u)  * v + dx(u)  * dx(v)) 
        + int2d(Th)(dy(u0) * v + dx(u0) * dx(v))
        - int2d(Th)(g * v) 
        + on(1, 2, 4, u = 0);

    u = u + u0;
    return u[];
}


// * Adjoint problem
func real[int] AdjointProblem(real[int] uu){
    Vh p, v;
    real[int] delta = GetFinalTime(uu) - w;
    Vh pT = 0; 
    for (int i = 0; i <= Nx; i++){
        pT[][i] = delta[i];
    }
    //cout << "delta min and max: " << delta.min << ", " << delta.max << endl;
    cout << "pT min and max: " << pT[].min << ", " << pT[].max << endl;
    solve SpaceTime(p, v, solver = sparsesolver) =
          int2d(Th)(dy(p) * v + dx(p) * dx(v))
        + int2d(Th)(dy(pT) * v + dx(pT) * dx(v))
        + on(2, 4, p = 0) + on(1, p = 0);
    Vh res = p + pT;
    //return p[];
    return FlipTimeDirection(res[]);
}


// Tikhonov functional
func real J(real[int] ff) {
    Vh u; u[] = StateProblem(ff); 
    real[int] delta = GetFinalTime(u[]) - w;
    return 0.5 * InnerProductOnTime(delta, delta) + 0.5 * gamma * InnerProductOnSpace(ff, ff);
}


// Gradient of Tikhonov funtional
func real[int] GradJ(real[int] ff) {
    real[int] uu = StateProblem(ff);
    Vh p; p[] = AdjointProblem(uu);
    Vh qp = p * q;
    real[int] res = IntegralOnTime(qp[]) + gamma * ff;
    return res;
}

func real Draw(real[int] f1, real[int] f2){
    Vh ff1 = 0; ff1[] = SpaceToQ(f1);
    Vh ff2 = 0; ff2[] = SpaceToQ(f2);
    /*for (int i = 0; i <= Ny; i++){
        ff1[][i * (Nx + 1)] = f1[i];
        ff2[][i * (Nx + 1)+2] = f2[i];
    }*/
    plot(ff1, ff2, wait = true, dim = 3);
    return 1;
}


real[int] fh(Ny + 1);
//fh = ffe;
IPOPT(J, GradJ, fh, tol = 0.5e-4);
real[int] test = ffe - fh;
cout << "(ffe - fh) min and max: " << test.min << ", " << test.max << endl;
Draw(ffe, fh);


/*
//******************************
// CG method

Vh uh, ph;
real[int] fh(Ny + 1), rh(Ny + 1), dh(Ny + 1), rhold(Ny + 1);
//fh = ffe;
uh[] = StateProblem2() + StateProblem1(SpaceToQ(fh));
//cout << GetFinalTime(uh[]) << endl;
//cout << w << endl;
plot(uh, ue, wait = 1, dim=3d);

for (int iter = 0; iter < 100; iter++){
    cout << endl << endl << endl << endl;
    cout << "==========================>>>>>>>>>>>>>> " << iter << endl;
    real[int] test = ffe - fh;
    cout << "(ffe - fh) min and max: " << test.min << ", " << test.max << endl;
    Draw(ffe, fh);
    //cout << endl << fh << endl << endl;
    cout << endl << "Adjoint problem" << endl;
    ph[] = AdjointProblem(uh[]);
    //cout << GetInitialTime(ph[]) << endl;
    real[int] delta = GetFinalTime(uh[]) - w;
    cout << delta << endl;
    cout << GetFinalTime(ph[]) << endl;
    //plot(uh, ue, wait = 1, dim=3d);

    rhold = rh;
    Vh qp = q * ph; 
    rh = -IntegralOnTime(qp[]) - gamma * fh;
    //cout << endl << rh << endl << endl;
    if (iter > 0){
        real beta = InnerProductOnSpace(rh, rh) / InnerProductOnSpace(rhold, rhold);
        dh = rh + beta * dh;
        cout << "beta: "  << beta << endl;
    }else{
        dh = rh;
    }
    //cout << endl << dh << endl << endl;
    cout << endl << "Solution udh" << endl;
    Vh udh; udh[] = StateProblem1(SpaceToQ(dh));
    real[int] tem = GetFinalTime(udh[]);

    real alpha = InnerProductOnSpace(rh, rh) / (InnerProductOnSpace(tem, tem) + gamma * InnerProductOnSpace(dh, dh));
    cout << endl << endl;
    cout << "rh ===>>> " << rh.min <<", " << rh.max << endl;
    cout << "alpha: " << alpha << endl;
    cout << "Norm (rh, rh): " << InnerProductOnSpace(rh, rh) << ", " << InnerProductOnSpace(dh, rh)<< endl;
    Vh temp; temp[] = FlipTimeDirection(udh[]);
    cout << "Mau 1: " << int1d(Th, 1)(temp * temp) << ", " << InnerProductOnSpace(tem, tem) << endl;
    cout << "Mau 2: " << gamma * InnerProductOnSpace(dh, dh) << endl;

    fh = fh + alpha * dh;
    //uh = uh + alpha * udh;
    uh[] = StateProblem2() + StateProblem1(SpaceToQ(fh));
}


plot(ue, dim=3, wait =1);
plot(uh, dim=3, wait =1);
plot(uh, ue, dim=3, wait =1);

//
//******************************



//Vh fh = 0;
//IPOPT(J, GradJ, fh[], tol = 1e-6);
//NLCG(GradJ, fh[], nbiter = 1000, eps = -1e-6);
//LinearCG(GradJ, f[], eps = 1e-6);

//cout << "J: " << J(fh[]) << endl; 


//savemesh(Th, "IP1.mesh");
//savesol("IP1.sol", Th, f);
//savemesh(Th, "IPe.mesh");
//savesol("IPe.sol", Th, fe);

//plot(fe, wait = true, dim = 3);
//plot(fh, wait = true, dim = 3);
//plot(fh, fe, wait = true, dim = 3);

//Vh delta = fh - fe;

//cout << "kq: " << fe[].min << ", " << fe[].max << endl;
//cout << "kq: " << fh[].min << ", " << fh[].max << endl;
//cout << "delta: " << delta[].min << ", " << delta[].max << endl;
//cout << "ss: " << sqrt(int2d(Th)(delta^2)) << endl;
*/