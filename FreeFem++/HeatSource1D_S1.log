-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "ff-IpOpt"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\ff-IpOpt = 0)
    2 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    3 :
    4 : real T = 1;
    5 : int nn = 20;
    6 : int Nx = nn, Ny = nn;
    7 : int[int] labs = [1, 2, 0, 4];
    8 : mesh Th = square(Nx, Ny, [x, T * y], label = labs);
    9 : fespace Vh(Th, P1);
   10 :
   11 :
   12 : Vh ue = exp(y) * sin(pi * x);
   13 : Vh duex = exp(y) * cos(pi * x) * pi;
   14 : Vh uN = (x == 1) * duex - (x == 0) * duex;
   15 : Vh u0 = ue(x, 0);
   16 :
   17 : //Vh fe = x * (1-x) * y * (1-y);
   18 : Vh fe = 1 * sin(pi * x) * sin(pi * y);
   19 : //Vh fe = (x * (x <= 0.5) + (1 - x) * (x > 0.5)) * y * (1-y);
   20 :
   21 : Vh q = 1;// + x * y;
   22 : Vh g = (1 + pi^2) * ue - fe * q;
   23 : real gamma = 1e-6;
   24 :
   25 :
   26 : func real[int] flip(real[int] uu){
   27 :     Vh u;
   28 :     for (int i = 0; i <= Ny/2; i++){
   29 :         for (int j = 0; j <= Nx; j++){
   30 :             u[][i * (Nx + 1) + j] = uu[(Ny - i) * (Nx + 1) + j];
   31 :             u[][(Ny - i) * (Nx + 1) + j] = uu[i * (Nx + 1) + j];
   32 :         }
   33 :     }
   34 :     return u[];
   35 : }
   36 :
   37 :
   38 : // State equation:
   39 : func real[int] StateProblem(real[int] ff){
   40 :     Vh u, v, f; f[] = ff;
   41 :     Vh rsh = f * q + g;
   42 :
   43 :     solve SpaceTime(u, v, solver = sparsesolver) =
   44 :           int2d(Th)(dy(u)  * v + dx(u)  * dx(v))
   45 :         + int2d(Th)(dy(u0) * v + dx(u0) * dx(v))
   46 :         - int1d(Th, 2, 4) (uN * v)
   47 :         - int2d(Th)(rsh * v)
   48 :         + on(1, u = 0);
   49 :
   50 :     u = u + u0;
   51 :     return u[];
   52 : }
   53 :
   54 : func real[int] StateProblem1(real[int] ff){
   55 :     Vh u, v, f; f[] = ff;
   56 :     Vh rsh = q * f;
   57 :
   58 :     solve SpaceTime(u, v, solver = sparsesolver) =
   59 :           int2d(Th)(dy(u) * v + dx(u) * dx(v))
   60 :         - int2d(Th)(rsh * v)
   61 :         + on(1, u = 0);
   62 :
   63 :     return u[];
   64 : }
   65 :
   66 : func real[int] StateProblem2(){
   67 :     Vh u, v;
   68 :
   69 :     solve SpaceTime(u, v, solver = sparsesolver) =
   70 :           int2d(Th)(dy(u)  * v + dx(u)  * dx(v))
   71 :         + int2d(Th)(dy(u0) * v + dx(u0) * dx(v))
   72 :         - int1d(Th, 2, 4) (uN * v)
   73 :         - int2d(Th)(g * v)
   74 :         + on(1, u = 0);
   75 :
   76 :     u = u + u0;
   77 :     return u[];
   78 : }
   79 :
   80 :
   81 :
   82 :
   83 : // Adjoint equation
   84 : func real[int] AdjointProblem(real[int] uu){
   85 :     Vh p, v, u; u[] = uu;
   86 :     Vh temp = u - ue;
   87 :     Vh pN; pN[] =  flip(temp[]);
   88 :
   89 :     solve SpaceTime(p, v, solver = sparsesolver) =
   90 :           int2d(Th)(dy(p) * v + dx(p) * dx(v))
   91 :         - int1d(Th, 2, 4)(pN * v)
   92 :         + on(1, p = 0);
   93 :
   94 :     return flip(p[]);
   95 : }
   96 :
   97 :
   98 : // Tikhonov functional
   99 : func real J(real[int] ff) {
  100 :     Vh f; f[] = ff;
  101 :     Vh u; u[] = StateProblem(ff);
  102 :     return 0.5 * int1d(Th, 2, 4)((u - ue) * (u - ue)) + 0.5 * gamma * int2d(Th)(f^2);
  103 : }
  104 :
  105 :
  106 : // Gradient of Tikhonov funtional
  107 : func real[int] GradJ(real[int] ff) {
  108 :     Vh f; f[] = ff;
  109 :     real[int] uu = StateProblem(ff);
  110 :     Vh p; p[] = AdjointProblem(uu);
  111 :     Vh res = q * p + gamma * f;
  112 :     return res[];
  113 : }
  114 :
  115 :
  116 : Vh uh, fh = 0;
  117 : Vh ph;
  118 : Vh rh, rh0, rhold;
  119 : Vh dh;
  120 : //******************************
  121 : // CG method
  122 :
  123 :
  124 : uh[] = StateProblem2();
  125 :
  126 : for (int iter = 0; iter < 100; iter++){
  127 :
  128 :
  129 :     ph[] = AdjointProblem(uh[]);
  130 :
  131 :     plot(fh, fe, wait = 1, dim=3d);
  132 :     //cout << "Min and Max: =======>>>>>>> "<<fh[].min<<" +++ " << fh[].max << endl;
  133 :
  134 :     rhold = rh;
  135 :     rh = -(q * ph + gamma * fh); //-Gradient J(f)
  136 :     if (iter == 0){
  137 :         rh0 = rh;
  138 :     }
  139 :
  140 :     //cout << iter << " GradJ: " << int2d(Th)(rh * rh) << endl;
  141 :     cout << iter << " J: " << 0.5 * int2d(Th)((uh - ue)^2) + 0.5 * gamma * int2d(Th)(fh^2) << endl;
  142 :
  143 :     if ( int2d(Th)((uh-ue)^2) < 5e-5){
  144 :         cout << "I love you" << endl;
  145 :         break;
  146 :     }
  147 :
  148 :     if (iter > 0){
  149 :         real beta = int2d(Th)(rh * rh) / int2d(Th)(rhold * rhold);
  150 :         dh = rh + beta * dh;
  151 :         cout << "beta: "  << beta << endl;
  152 :         if(beta>1){
  153 :             cout << "I love you" << endl;
  154 :             //break;
  155 :         }
  156 :     }else{
  157 :         dh = rh;
  158 :     }
  159 :
  160 :     Vh udh; udh[] = StateProblem1(dh[]);
  161 :     real alpha = int2d(Th)(dh * rh) / (int1d(Th, 2, 4)(udh * udh) + gamma * int2d(Th)(dh * dh));
  162 :     cout << "alpha: " << alpha << endl;
  163 :     fh = fh + alpha * dh;
  164 :     uh = uh + alpha * udh;
  165 : }
  166 :
  167 : //
  168 : //******************************
  169 :
  170 :
  171 : //Vh fh = 0;
  172 : //IPOPT(J, GradJ, fh[], tol = 1e-4, maxiter = 100);
  173 : //NLCG(GradJ, fh[], nbiter = 1000, eps = -1e-6);
  174 : //LinearCG(GradJ, f[], eps = 1e-6);
  175 :
  176 : cout << "J: " << J(fh[]) << endl;
  177 :
  178 :
  179 : //savemesh(Th, "IP1.mesh");
  180 : //savesol("IP1.sol", Th, f);
  181 : //savemesh(Th, "IPe.mesh");
  182 : //savesol("IPe.sol", Th, fe);
  183 :
  184 : Vh delta = fh - fe;
  185 :
  186 : cout << "kq: " << fe[].min << ", " << fe[].max << endl;
  187 : cout << "kq: " << fh[].min << ", " << fh[].max << endl;
  188 : cout << "delta: " << delta[].min << ", " << delta[].max << endl;
  189 : cout << "ss: " << sqrt(int2d(Th)(delta^2)) << endl;
  190 :  sizestack + 1024 =11968  ( 10944 )
 
  -- Square mesh : nb vertices  =441 ,  nb triangles = 800 ,  nb boundary edges 80
  -- Solve :
          min -0.43825  max 1.28026
  -- Solve :
          min -0.415737  max 2.33472e-033
0 J: 0.0338494
  -- Solve :
          min -5.35153e-034  max 0.292967
alpha: 1.2319
  -- Solve :
          min -0.0310258  max 0.0372976
1 J: 0.00103739
beta: 0.00424599
  -- Solve :
          min -0.00650893  max 0.00624944
alpha: 10.925
  -- Solve :
          min -0.000808529  max 0.00572579
^C try getConsole D:\Study\HUST\FEM\heatsource\FreeFem++\HeatSource1D_S1.edp
